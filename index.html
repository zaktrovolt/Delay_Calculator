<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Delay Calculator</title>
  <style>
    body {
      font-family: 'Tahoma', sans-serif;
      background-image:linear-gradient(rgba(0, 0, 0, 0.6)),repeating-linear-gradient(45deg, #606dbc, #606dbc 5px, #465298 5px, #465298 20px), url(data:image/png;base64,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);
      background-blend-mode: multiply;
     }
    .window {
      background-color: #DFDFDF;
      border: 2px solid #000;
      width: 600px;
      margin: 20px auto;
      padding: 16px;
      box-shadow: inset -2px -2px 0 #fff, inset 2px 2px 0 #808080;
     }

    .title-bar {
      background: #000080;
      color: #fff;
      padding: 4px 8px;
      font-weight: bold;
      text-align: left;
      margin-bottom: 10px;
     }

    .input-label {
      margin-top: 12px;
      font-weight: bold;
      display: block;
     }

    input[type="number"] {
      width: calc(100% - 12px);
      padding: 5px;
      margin-top: 4px;
      border: 2px solid #808080;
      box-shadow: inset -1px -1px 0 #fff, inset 1px 1px 0 #404040;
      background-color: #fff;
      font-family: 'Tahoma', sans-serif;
     }

    .section {
      margin-top: 20px;
      border: 2px solid #f;
      padding: 10px;
      box-shadow: inset -2px -2px 0 #fff, inset 2px 2px 0 #808080;
      background-color: #dfdfdf;
     }

    .section-title {
      font-weight: bold;
      margin-bottom: 8px;
      border-bottom: 1px solid #000;
      padding-bottom: 4px;
     }

    .list-item {
      display: flex;
      align-items: center;
      font-size: 14px;
      padding: 4px 0;
      cursor: pointer;
      border-bottom: 1px solid #808080;
      background-color: #dfdfdf;
      padding-left: 5px;
      padding-right: 5px;
     }
    .list-item:last-child {
      border-bottom: none;
     }
    .list-item:hover:not(.selected) {
       background-color: #b0b0b0;
     }
    .list-item.selected {
       background-color: #cce0ff !important;
       border-color: #000080 !important;
       box-shadow: inset 1px 1px 0 #fff, inset -1px -1px 0 #808080 !important;
     }

    .list-item input[type="checkbox"] {
        margin-right: 8px;
    }


    .note-name {
       flex-grow: 1;
     }

    .delay-canvas {
       width: 21.5px;
       height: 21.5px;
       margin: 0 10px;
       border: 1px solid #bbb;
       box-shadow: inset 1px 1px 0 #fff, inset -1px -1px 0 #808080;
     }

    .delay-value {
      background: #C0C0C0;
      padding: 2px 6px;
      border: 2px outset #fff;
      font-family: monospace;
      min-width: 95px;
      text-align: right;
     }

     #oscilloscope-container {
       margin-top: 15px;
       padding: 8px;
       border: 0px solid #808080;
       box-shadow: inset -1px -1px 0 #fff, inset 1px 1px 0 #404040;
       background-color: #000;
     }
     #oscilloscopeCanvas {
       display: block;
       width: 100%;
       height: 100px;
       background-color: #000000;
     }
     #spectrogramCanvas {
        display: block;
        width: 100%;
        height: 80px;
        background-color: black;
        margin-top: 5px;
     }


     footer {
       margin-top: 40px;
       text-align: center;
       font-size: 12px;
       color: #000;
    }

    button {
        font-family: 'Tahoma', sans-serif;
        cursor: pointer;
    }

  </style>
</head>
<body>

  <div class="window">
    <div class="title-bar">Tempo-Synced Delay Calculator</div>

    <label for="bpm" class="input-label">Enter BPM:</label>
    <input type="number" id="bpm" min="1" max="500" value="120" />
    <label class="input-label" style="display: flex; align-items: center; gap: 8px; margin-top: 16px;">
      <input type="checkbox" id="roundToggle" checked />
      Round to whole numbers
    </label>


    <div id="results-container" class="section" style="margin-top: 16px;">
        </div>

    <div class="section" style="margin-top: 10px; text-align: center; padding: 8px;">
        <button id="playSelectedBtn" style="padding: 8px 15px; margin-right: 10px; background-color: #C0C0C0; border: 2px outset #fff;">Play Selected Delays</button>
        <button id="clearSelectionBtn" style="padding: 8px 15px; margin-right: 10px; background-color: #C0C0C0; border: 2px outset #fff;">Clear Selection</button>
         <button id="stopAudioBtn" style="padding: 8px 15px; background-color: #C0C0C0; border: 2px outset #fff;">Stop Audio</button>
    </div>


    <div id="oscilloscope-container" class="section">
        <canvas id="oscilloscopeCanvas"></canvas>
        <canvas id="spectrogramCanvas"></canvas>
    </div>

<footer>
  &copy; <span id="currentYear"></span> /dmp/ Delay Calculator. All delays shown in milliseconds (ms).
</footer>
  </div>

  <script>
  const bpmInput = document.getElementById('bpm');
  const resultsContainer = document.getElementById('results-container');
  const roundToggle = document.getElementById('roundToggle');
  const currentYearSpan = document.getElementById('currentYear');
  const oscilloscopeCanvas = document.getElementById('oscilloscopeCanvas');
  const oscilloscopeCtx = oscilloscopeCanvas.getContext('2d');
  const spectrogramCanvas = document.getElementById('spectrogramCanvas');
  const spectrogramCtx = spectrogramCanvas.getContext('2d');


  const noteDefinitions = [
    { name: "Whole Note (1/1)", type: "standard", factor: 4 },
    { name: "Half Note (1/2)", type: "standard", factor: 2 },
    { name: "Quarter Note (1/4)", type: "standard", factor: 1 },
    { name: "8th Note (1/8)", type: "standard", factor: 0.5 },
    { name: "16th Note (1/16)", type: "standard", factor: 0.25 },
    { name: "32nd Note (1/32)", type: "standard", factor: 0.125 },
    { name: "64th Note (1/64)", type: "standard", factor: 0.0625 },
    { name: "Dotted Half Note", type: "dotted", factor: 2 * 1.5 },
    { name: "Dotted Quarter Note", type: "dotted", factor: 1 * 1.5 },
    { name: "Dotted 8th Note", type: "dotted", factor: 0.5 * 1.5 },
    { name: "Dotted 16th Note", type: "dotted", factor: 0.25 * 1.5 },
    { name: "Dotted 32nd Note", type: "dotted", factor: 0.125 * 1.5 },
    { name: "Half Note Triplet", type: "triplet", baseNoteFactor: 4, divisor: 3 },
    { name: "Quarter Note Triplet", type: "triplet", baseNoteFactor: 2, divisor: 3 },
    { name: "8th Note Triplet", type: "triplet", baseNoteFactor: 1, divisor: 3 },
    { name: "16th Note Triplet", type: "triplet", baseNoteFactor: 0.5, divisor: 3 },
    { name: "32nd Note Triplet", type: "triplet", baseNoteFactor: 0.25, divisor: 3 },
   ];

  let audioContext;
  let analyser;
  let currentAudioSources = []; // Stores { node, timeoutId, gainNode } for audio sources
  let animationTimeouts = []; // Stores timeouts for canvas animations

  let oscilloscopeAnimationId = null;
  let spectrogramAnimationId = null;
  const canvasAnimationIds = {}; // Stores requestAnimationFrame IDs for per-canvas animations


  function initAudioContext() {
    if (!audioContext) {
      try {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 2048;
          analyser.smoothingTimeConstant = 0.8; // Add some smoothing for spectrogram

          // Connect analyser to destination here
          analyser.connect(audioContext.destination);

           // Start drawing loops once context is created
          if (!oscilloscopeAnimationId) {
              drawOscilloscope();
          }
           if (!spectrogramAnimationId) {
              drawSpectrogram();
           }

          console.log("AudioContext initialized.");

      } catch(e) {
          alert('Web Audio API is not supported in this browser');
          console.error("Error creating AudioContext:", e);
      }
    }
  }

  function playClickScheduled(absoluteTime, volume, tickDurationMs, canvasId, tickNumber) {
    if (!audioContext || !analyser) return;

    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();

    oscillator.type = 'sine';
    oscillator.frequency.setValueAtTime(660, audioContext.currentTime);

    const attackTime = 0.001;
    const decayTime = 0.05;

    
    gainNode.gain.setValueAtTime(0, absoluteTime);
    gainNode.gain.linearRampToValueAtTime(volume, absoluteTime + attackTime);
    gainNode.gain.linearRampToValueAtTime(0, absoluteTime + attackTime + decayTime);


    oscillator.connect(gainNode);
    gainNode.connect(analyser); 
    gainNode.connect(audioContext.destination); 

    oscillator.start(absoluteTime);
    oscillator.stop(absoluteTime + attackTime + decayTime + 0.01);

    
    const sourceInfo = {
        node: oscillator,
        timeoutId: null, 
        gainNode: gainNode 
    };
    currentAudioSources.push(sourceInfo);

    
    const animationDelayMs = (absoluteTime - audioContext.currentTime) * 1000;
     if (animationDelayMs >= -50) { 
        const animationTimeoutId = setTimeout(() => {
            const canvas = document.getElementById(canvasId);
            if (canvas) {
                animateTick(canvas, tickNumber, 4);
            }
        }, Math.max(0, animationDelayMs)); 
        sourceInfo.timeoutId = animationTimeoutId;
        animationTimeouts.push(animationTimeoutId); 
     } else {
         
         console.warn("Animation scheduled too far in the past, skipping:", animationDelayMs);
     }
  }


  function animateTick(canvas, tickNumber, totalTicks) {
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    const radius = Math.min(width, height) / 3;
    const centerX = width / 2;
    const centerY = height / 2;

    const baseOpacity = 1.0;
    let opacity = baseOpacity;
    if (tickNumber === 2) opacity *= 0.75;
    if (tickNumber === 3) opacity *= 0.50;
    if (tickNumber === 4) opacity *= 0.25;

    let animationProgress = 0;
    const animationDuration = 150; 
    let startTime = null;

    function drawPulse(timestamp) {
        if (!startTime) startTime = timestamp;
        const elapsed = timestamp - startTime;
        animationProgress = Math.min(elapsed / animationDuration, 1);

        ctx.clearRect(0, 0, width, height);
        const currentOpacity = opacity * (1 - animationProgress); 
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius * (0.5 + animationProgress * 0.5) , 0, 2 * Math.PI, false);
        ctx.fillStyle = `rgba(0, 0, 128, ${currentOpacity})`;
        ctx.fill();

        if (animationProgress < 1) {
            
            canvasAnimationIds[canvas.id] = requestAnimationFrame(drawPulse);
        } else {
            
            delete canvasAnimationIds[canvas.id];
            ctx.clearRect(0, 0, width, height);
        }
    }

    
    if (canvasAnimationIds[canvas.id]) {
        cancelAnimationFrame(canvasAnimationIds[canvas.id]);
    }
    
    canvasAnimationIds[canvas.id] = requestAnimationFrame(drawPulse);
  }


  function drawOscilloscope() {
      if (!analyser || !oscilloscopeCanvas || !oscilloscopeCtx) {
           oscilloscopeAnimationId = null; 
           return;
      }
      oscilloscopeAnimationId = requestAnimationFrame(drawOscilloscope);

      const bufferLength = analyser.frequencyBinCount;
      const dataArray = new Uint8Array(bufferLength);
      analyser.getByteTimeDomainData(dataArray);

      const canvasWidth = oscilloscopeCanvas.width;
      const canvasHeight = oscilloscopeCanvas.height;

      oscilloscopeCtx.fillStyle = '#000000';
      oscilloscopeCtx.fillRect(0, 0, canvasWidth, canvasHeight);

      oscilloscopeCtx.lineWidth = 2;
      oscilloscopeCtx.strokeStyle = '#00FF00';
      oscilloscopeCtx.beginPath();

      const sliceWidth = canvasWidth * 1.0 / bufferLength;
      let x = 0;

      for (let i = 0; i < bufferLength; i++) {
        const v = dataArray[i] / 128.0;
        const y = v * canvasHeight / 2;

        if (i === 0) {
          oscilloscopeCtx.moveTo(x, y);
        } else {
          oscilloscopeCtx.lineTo(x, y);
        }

        x += sliceWidth;
      }

      oscilloscopeCtx.lineTo(canvasWidth, canvasHeight / 2);
      oscilloscopeCtx.stroke();
  }

  function drawSpectrogram() {
      if (!analyser || !spectrogramCanvas || !spectrogramCtx) {
           spectrogramAnimationId = null; 
           return;
      }
      spectrogramAnimationId = requestAnimationFrame(drawSpectrogram);

      const width = spectrogramCanvas.width;
      const height = spectrogramCanvas.height;
      const bufferLength = analyser.frequencyBinCount;
      const dataArray = new Uint8Array(bufferLength);
      analyser.getByteFrequencyData(dataArray);

      
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = width;
      tempCanvas.height = height;
      const tempCtx = tempCanvas.getContext('2d');

      tempCtx.drawImage(spectrogramCanvas, 1, 0, width - 1, height, 0, 0, width - 1, height);

      spectrogramCtx.fillStyle = '#000';
      spectrogramCtx.fillRect(0, 0, width, height);
      spectrogramCtx.drawImage(tempCanvas, 0, 0);


      
      for (let y = 0; y < height; y++) {
        const freqIndex = Math.floor((1 - y / height) * bufferLength); 
        const value = dataArray[freqIndex];
        
        const color = `rgb(${value}, ${value}, ${value})`;
        spectrogramCtx.fillStyle = color;
        spectrogramCtx.fillRect(width - 1, y, 1, 1);
      }
  }


  let selectedDelays = []; 

  function toggleDelaySelection(event) {
      const checkbox = event.target;
      const listItem = checkbox.closest('.list-item');
      const rawValue = parseFloat(checkbox.dataset.rawValue);
      const canvasId = checkbox.dataset.canvasId;
      const name = checkbox.dataset.noteName;

      const delayData = { name, rawValue, canvasId };

      if (checkbox.checked) {
          
          if (!selectedDelays.find(d => d.canvasId === canvasId)) {
              selectedDelays.push(delayData);
              listItem.classList.add('selected'); 
          }
      } else {
          
          selectedDelays = selectedDelays.filter(d => d.canvasId !== canvasId);
          listItem.classList.remove('selected'); 
      }
      
  }

  function handleListItemClick(event) {
      
      if (event.target.type !== 'checkbox' && event.target.tagName !== 'LABEL') {
          const checkbox = event.currentTarget.querySelector('.delay-checkbox');
          if (checkbox) {
              checkbox.checked = !checkbox.checked;
              
              const changeEvent = new Event('change');
              checkbox.dispatchEvent(changeEvent);
          }
      }
      
  }


  function playSelectedDelays() {
      initAudioContext();
      if (!audioContext || selectedDelays.length === 0) {
          console.log("No delays selected or audio context not initialized.");
          return;
      }

      
      if (audioContext.state === 'suspended') {
          audioContext.resume().then(() => {
              console.log("AudioContext resumed.");
              
              stopCurrentEffects();
              startSchedulingDelays();
          }).catch(e => console.error("Error resuming audio context:", e));
      } else {
          
           stopCurrentEffects();
           startSchedulingDelays();
      }
  }

  function startSchedulingDelays() {
       const now = audioContext.currentTime;

      selectedDelays.forEach(delay => {
          const delayMs = delay.rawValue;
          const tickDurationSec = delayMs / 1000;
          const totalTicks = 4; 
          const baseVolume = 0.3; 

          for (let i = 0; i < totalTicks; i++) {
              const tickTimeSec = tickDurationSec * i;
              let tickVolume = baseVolume;
              if (i === 1) tickVolume *= 0.70;
              if (i === 2) tickVolume *= 0.40;
              if (i === 3) tickVolume *= 0.15;

              
              playClickScheduled(now + tickTimeSec, tickVolume, delayMs, delay.canvasId, i + 1);
          }
      });
  }

  function stopAudio() {
       stopCurrentEffects();
       console.log("Audio Stopped.");
  }

  function stopCurrentEffects() {
      
      currentAudioSources.forEach(sourceInfo => {
          if (sourceInfo.node) {
              try {
                  sourceInfo.node.stop();
                  sourceInfo.node.disconnect();
              } catch (e) { console.error("Error stopping node:", e); }
          }
          if (sourceInfo.gainNode) {
              try {
                  sourceInfo.gainNode.disconnect();
              } catch (e) { console.error("Error disconnecting gain node:", e); }
          }
          if (sourceInfo.timeoutId) {
              clearTimeout(sourceInfo.timeoutId);
          }
      });
      currentAudioSources = []; 

      
      animationTimeouts.forEach(clearTimeout);
      animationTimeouts = [];

      
      for (const canvasId in canvasAnimationIds) {
          if (canvasAnimationIds.hasOwnProperty(canvasId)) {
              cancelAnimationFrame(canvasAnimationIds[canvasId]);
              delete canvasAnimationIds[canvasId];
          }
      }

      
      document.querySelectorAll('.delay-canvas').forEach(canvas => {
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
      });

       
  }


  function clearSelectedDelays() {
      selectedDelays = [];
      document.querySelectorAll('.delay-checkbox').forEach(checkbox => {
          checkbox.checked = false;
      });
      document.querySelectorAll('.list-item').forEach(item => {
          item.classList.remove('selected'); 
      });
       stopAudio(); 
      console.log("Selected Delays Cleared.");
  }


  function calculateAndDisplayDelays() {
    const bpm = parseFloat(bpmInput.value);
    const roundValues = roundToggle.checked;

    if (isNaN(bpm) || bpm <= 0) {
      resultsContainer.innerHTML = '<p style="color: #333; padding: 10px;">Enter a valid BPM to see delay times.</p>';
      return;
    }

    const quarterNoteDelay = 60000 / bpm;
    const groupedNotes = { standard: [], dotted: [], triplet: [] };

    noteDefinitions.forEach((note, index) => {
      let delayMs;
      if (note.type === "triplet") {
        delayMs = (quarterNoteDelay * note.baseNoteFactor) / note.divisor;
      } else {
        delayMs = quarterNoteDelay * note.factor;
      }

      const displayValue = roundValues ? Math.round(delayMs) : delayMs.toFixed(2);
      const canvasId = `canvas-${note.type}-${index}`;
      groupedNotes[note.type].push({
          name: note.name,
          value: displayValue,
          rawValue: delayMs,
          canvasId: canvasId,
          noteType: note.type 
      });
    });

    const createSection = (title, notes) => {
      if (notes.length === 0) return '';
      let html = `<div class="section-title">${title}</div>`;
      notes.forEach(note => {
          const isSelected = selectedDelays.some(d => d.canvasId === note.canvasId);
          const selectedClass = isSelected ? 'selected' : '';
        html += `
          <div class="list-item ${selectedClass}" data-canvas-id="${note.canvasId}" data-raw-value="${note.rawValue}" data-note-name="${note.name}">
              <input type="checkbox" class="delay-checkbox" id="checkbox-${note.canvasId}"
                     data-raw-value="${note.rawValue}" data-canvas-id="${note.canvasId}" data-note-name="${note.name}"
                     ${isSelected ? 'checked' : ''}>
              <label for="checkbox-${note.canvasId}" class="note-name" style="flex-grow: 1; cursor: pointer;">${note.name}</label>
              <canvas id="${note.canvasId}" class="delay-canvas" width="30" height="30"></canvas>
              <span class="delay-value">${note.value} ms</span>
            </div>`;
      });
      return html;
    };

    resultsContainer.innerHTML =
      createSection("Standard Note Delays", groupedNotes.standard) +
      createSection("Dotted Note Delays", groupedNotes.dotted) +
      createSection("Triplet Note Delays", groupedNotes.triplet);

    
    document.querySelectorAll('.delay-checkbox').forEach(checkbox => {
        
        checkbox.removeEventListener('change', toggleDelaySelection);
        checkbox.addEventListener('change', toggleDelaySelection);
    });

     
     document.querySelectorAll('.list-item').forEach(item => {
        item.removeEventListener('click', handleListItemClick);
        item.addEventListener('click', handleListItemClick);
     });

     
     document.getElementById('playSelectedBtn').removeEventListener('click', playSelectedDelays);
     document.getElementById('playSelectedBtn').addEventListener('click', playSelectedDelays);

     document.getElementById('clearSelectionBtn').removeEventListener('click', clearSelectedDelays);
     document.getElementById('clearSelectionBtn').addEventListener('click', clearSelectedDelays);

     document.getElementById('stopAudioBtn').removeEventListener('click', stopAudio);
     document.getElementById('stopAudioBtn').addEventListener('click', stopAudio);


     
     groupedNotes.standard.concat(groupedNotes.dotted, groupedNotes.triplet).forEach(note => {
         const canvas = document.getElementById(note.canvasId);
         if (canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height); 
         }
     });
  }


  
  bpmInput.addEventListener('input', calculateAndDisplayDelays);
   
  bpmInput.addEventListener('change', () => {
      stopAudio();
      calculateAndDisplayDelays();
  });

  roundToggle.addEventListener('change', calculateAndDisplayDelays);


  document.addEventListener('DOMContentLoaded', () => {
    currentYearSpan.textContent = new Date().getFullYear();
    if (!bpmInput.value) bpmInput.value = 120;

    
    const oscContainer = document.getElementById('oscilloscope-container');
    if (oscContainer && oscilloscopeCanvas && spectrogramCanvas) {
        oscilloscopeCanvas.width = oscContainer.clientWidth - 16;
        oscilloscopeCanvas.height = 100;
        spectrogramCanvas.width = oscContainer.clientWidth - 16;
        spectrogramCanvas.height = 80;
    }


    
    const initializeOnFirstGesture = () => {
        initAudioContext();
        document.body.removeEventListener('click', initializeOnFirstGesture);
        document.body.removeEventListener('touchstart', initializeOnFirstGesture);
        document.body.removeEventListener('keydown', initializeOnFirstGesture);
    };
    document.body.addEventListener('click', initializeOnFirstGesture, { once: true });
    document.body.addEventListener('touchstart', initializeOnFirstGesture, { once: true });
    document.body.addEventListener('keydown', initializeOnFirstGesture, { once: true });


    calculateAndDisplayDelays(); 
  });

  window.addEventListener('beforeunload', () => {
      
      

      stopCurrentEffects(); 

      
       if (oscilloscopeAnimationId) {
           cancelAnimationFrame(oscilloscopeAnimationId);
           oscilloscopeAnimationId = null;
       }
       if (spectrogramAnimationId) {
           cancelAnimationFrame(spectrogramAnimationId);
           spectrogramAnimationId = null;
       }


      if(audioContext && audioContext.state !== 'closed') {
          audioContext.close().then(() => console.log("AudioContext closed.")).catch(e => console.error("Error closing AudioContext:", e));
      }
  });

  window.addEventListener('resize', () => {
      
    const oscContainer = document.getElementById('oscilloscope-container');
    if (oscContainer && oscilloscopeCanvas && spectrogramCanvas) {
      oscilloscopeCanvas.width = oscContainer.clientWidth - 16;
      spectrogramCanvas.width = oscContainer.clientWidth - 16;
       
    }
  });


  
  let hue = 0;
  const bgInterval = setInterval(() => {
    
    hue = (hue + 1) % 360;
  }, 100);


  </script>
</body>
</html>
