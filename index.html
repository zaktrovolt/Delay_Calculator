<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Delay Calculator</title>
  <style>
    body {
      font-family: 'Tahoma', sans-serif;
      background-image:linear-gradient(rgba(0, 0, 0, 0.6)),repeating-linear-gradient(45deg, #606dbc, #606dbc 5px, #465298 5px, #465298 20px), url(data:image/png;base64,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);	  
      background-blend-mode: multiply;
     }
    .window {
      background-color: #DFDFDF;
      border: 2px solid #000;
      width: 600px; 
      margin: 20px auto;
      padding: 16px;
      box-shadow: inset -2px -2px 0 #fff, inset 2px 2px 0 #808080;
     }

    .title-bar {
      background: #000080;
      color: #fff;
      padding: 4px 8px;
      font-weight: bold;
      text-align: left;
      margin-bottom: 10px;
     }

    .input-label {
      margin-top: 12px;
      font-weight: bold;
      display: block;
     }

    input[type="number"] {
      width: calc(100% - 12px);
      padding: 5px;
      margin-top: 4px;
      border: 2px solid #808080;
      box-shadow: inset -1px -1px 0 #fff, inset 1px 1px 0 #404040;
      background-color: #fff;
      font-family: 'Tahoma', sans-serif;
     }

    .section {
      margin-top: 20px;
      border: 2px solid #f;
      padding: 10px;
      box-shadow: inset -2px -2px 0 #fff, inset 2px 2px 0 #808080;
      background-color: #dfdfdf; 
     }

    .section-title {
      font-weight: bold;
      margin-bottom: 8px;
      border-bottom: 1px solid #000;
      padding-bottom: 4px;
     }

    .list-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 14px;
      padding: 4px 0;
      cursor: pointer;
      border-bottom: 1px solid #808080; 
      background-color: #dfdfdf; 
      padding-left: 5px; 
      padding-right: 5px;
     }
    .list-item:last-child {
      border-bottom: none;
     }
    .list-item:hover {
       background-color: #b0b0b0; 
     }

    .note-name {
       flex-grow: 1;
     }

    .delay-canvas {
       width: 30px;
       height: 30px;
       margin: 0 10px;
       border: 1px solid #bbb;
       box-shadow: inset 1px 1px 0 #fff, inset -1px -1px 0 #808080;
     }

    .delay-value {
      background: #C0C0C0;
      padding: 2px 6px;
      border: 2px outset #fff;
      font-family: monospace;
      min-width: 95px;
      text-align: right;
     }

     #oscilloscope-container {
        margin-top: 15px;
        padding: 8px;
        border: 0px solid #808080;
        box-shadow: inset -1px -1px 0 #fff, inset 1px 1px 0 #404040;
        background-color: #000;
     }
     #oscilloscopeCanvas {
        display: block; 
        width: 100%;
        height: 100px; 
        background-color: #000000; 
     }

     footer {
	    margin-top: 40px;
	    text-align: center;
	    font-size: 12px;
	    color: #000; 
	}

  </style>
</head>
<body>
	
  <div class="window">
    <div class="title-bar">Tempo-Synced Delay Calculator</div>

    <label for="bpm" class="input-label">Enter BPM:</label>
    <input type="number" id="bpm" min="1" max="500" value="120" />
    <label class="input-label" style="display: flex; align-items: center; gap: 8px; margin-top: 16px;">
      <input type="checkbox" id="roundToggle" checked />
      Round to whole numbers
    </label>


    <div id="results-container" class="section" style="margin-top: 16px;">
	
      </div>
	    <div id="oscilloscope-container" class="section">
        <canvas id="oscilloscopeCanvas"></canvas>
		<canvas id="spectrogramCanvas" height="100" style="display: block; width: 100%; background-color: black;"></canvas>
    </div>
<footer>
  &copy; <span id="currentYear"></span> /dmp/ Delay Calculator. All delays shown in milliseconds (ms).
</footer>
  </div>

  <script>
  const bpmInput = document.getElementById('bpm');
  const resultsContainer = document.getElementById('results-container');
  const roundToggle = document.getElementById('roundToggle');
  const currentYearSpan = document.getElementById('currentYear');
  const oscilloscopeCanvas = document.getElementById('oscilloscopeCanvas'); 
  const oscilloscopeCtx = oscilloscopeCanvas.getContext('2d'); 

  const noteDefinitions = [
    { name: "Whole Note (1/1)", type: "standard", factor: 4 },
    { name: "Half Note (1/2)", type: "standard", factor: 2 },
    { name: "Quarter Note (1/4)", type: "standard", factor: 1 },
    { name: "8th Note (1/8)", type: "standard", factor: 0.5 },
    { name: "16th Note (1/16)", type: "standard", factor: 0.25 },
    { name: "32nd Note (1/32)", type: "standard", factor: 0.125 },
    { name: "64th Note (1/64)", type: "standard", factor: 0.0625 },
    { name: "Dotted Half Note", type: "dotted", factor: 2 * 1.5 },
    { name: "Dotted Quarter Note", type: "dotted", factor: 1 * 1.5 },
    { name: "Dotted 8th Note", type: "dotted", factor: 0.5 * 1.5 },
    { name: "Dotted 16th Note", type: "dotted", factor: 0.25 * 1.5 },
    { name: "Dotted 32nd Note", type: "dotted", factor: 0.125 * 1.5 },
    { name: "Half Note Triplet", type: "triplet", baseNoteFactor: 4, divisor: 3 },
    { name: "Quarter Note Triplet", type: "triplet", baseNoteFactor: 2, divisor: 3 },
    { name: "8th Note Triplet", type: "triplet", baseNoteFactor: 1, divisor: 3 },
    { name: "16th Note Triplet", type: "triplet", baseNoteFactor: 0.5, divisor: 3 },
    { name: "32nd Note Triplet", type: "triplet", baseNoteFactor: 0.25, divisor: 3 },
   ];
	const spectrogramCanvas = document.getElementById('spectrogramCanvas');
	const spectrogramCtx = spectrogramCanvas.getContext('2d');
	let spectrogramOffset = 0;

	function drawSpectrogram() {
	  if (!analyser || !audioContext) return;

	  const width = spectrogramCanvas.width;
	  const height = spectrogramCanvas.height;
	  const bufferLength = analyser.frequencyBinCount;
	  const dataArray = new Uint8Array(bufferLength);
	  analyser.getByteFrequencyData(dataArray);

	  // Shift image to the left
	  const imageData = spectrogramCtx.getImageData(2, 0, width - 1, height);
	  spectrogramCtx.putImageData(imageData, 0, 0);

	  // Draw new data on the right edge
	  for (let y = 0; y < height; y++) {
		const freqIndex = Math.floor((y / height) * bufferLength);
		const value = dataArray[freqIndex];
		const color = `rgb(${value}, ${value}, ${value})`;
		spectrogramCtx.fillStyle = color;
		spectrogramCtx.fillRect(width - 1, height - y, 1, 1);
	  }

	  requestAnimationFrame(drawSpectrogram);
	}

  let hue = 0;
  const bgInterval = setInterval(() => {
    hue = (hue + 1) % 360;
    document.body.style.filter = `hue-rotate(${hue}deg)`;
  }, 100);

  let audioContext;
  let analyser;
  let currentAudioSources = [];
  let currentAnimation = { requestId: null, timeouts: [] };
  let oscilloscopeAnimationId = null;

  function initAudioContext() {
    if (!audioContext) {
      try {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();

          
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 2048; 
          analyser.connect(audioContext.destination);
          drawOscilloscope();
		  drawSpectrogram();

      } catch(e) {
          alert('Web Audio API is not supported in this browser');
          console.error("Error creating AudioContext:", e);
      }
    }
  }

  function stopCurrentEffects() {
    currentAudioSources.forEach(source => {
      if (source.node) {
        try {
          source.node.stop();
          source.node.disconnect();
        } catch (e) {}
      }
      if (source.timeoutId) clearTimeout(source.timeoutId);
    });
    currentAudioSources = [];

    if (currentAnimation.requestId) {
      cancelAnimationFrame(currentAnimation.requestId);
      currentAnimation.requestId = null;
    }
    currentAnimation.timeouts.forEach(clearTimeout);
    currentAnimation.timeouts = [];

    document.querySelectorAll('.delay-canvas').forEach(canvas => {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    });

  }

  function playClick(time, volume, tickDurationMs, canvasId, tickNumber) {
    if (!audioContext || !analyser) return; 

    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();

    oscillator.type = 'sine';
    oscillator.frequency.setValueAtTime(660, audioContext.currentTime); 
	
    const now = audioContext.currentTime;
    const attackTime = 0.001;
    const decayTime = 0.05; 

    gainNode.gain.setValueAtTime(0, now + time);
    gainNode.gain.linearRampToValueAtTime(volume, now + time + attackTime);
    gainNode.gain.linearRampToValueAtTime(0, now + time + attackTime + decayTime);

    oscillator.connect(gainNode);
    gainNode.connect(analyser);

    oscillator.start(now + time);
    oscillator.stop(now + time + attackTime + decayTime + 0.01);

    currentAudioSources.push({ node: oscillator, timeoutId: null }); 
    const animationTimeoutId = setTimeout(() => {
      const canvas = document.getElementById(canvasId);
      if (canvas) {
        animateTick(canvas, tickNumber, 4); 
      }
    }, time * 1000);
    currentAnimation.timeouts.push(animationTimeoutId);
  }

  function playDelayEffect(delayMs, canvasId, noteType) {
    initAudioContext(); 
    if (!audioContext) return; 

    stopCurrentEffects();

    const totalTicks = 4;
    const baseVolume = 0.4;
	
    for (let i = 0; i < totalTicks; i++) {
      const tickTime = (delayMs / 1000) * i; 
      let tickVolume = baseVolume;
      if (i === 1) tickVolume *= 0.70; 
      if (i === 2) tickVolume *= 0.40;
      if (i === 3) tickVolume *= 0.15;

      playClick(tickTime, tickVolume, delayMs, canvasId, i + 1);
    }
  }

  function animateTick(canvas, tickNumber, totalTicks) {
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    const radius = Math.min(width, height) / 3;
    const centerX = width / 2;
    const centerY = height / 2;

    const baseOpacity = 1.0;
    let opacity = baseOpacity;
    if (tickNumber === 2) opacity *= 0.75;
    if (tickNumber === 3) opacity *= 0.50;
    if (tickNumber === 4) opacity *= 0.25;

    let animationProgress = 0; 
    const animationDuration = 150; // ms

    function drawPulse(progress) {
       ctx.clearRect(0, 0, width, height);
       const currentOpacity = opacity * (1 - progress); // Fade out
       ctx.beginPath();
       ctx.arc(centerX, centerY, radius * (0.5 + progress * 0.5) , 0, 2 * Math.PI, false);
       ctx.fillStyle = `rgba(0, 0, 128, ${currentOpacity})`; 
       ctx.fill();
     }

    let startTime = null;
    function animationStep(timestamp) {
       if (!startTime) startTime = timestamp;
       const elapsed = timestamp - startTime;
       animationProgress = Math.min(elapsed / animationDuration, 1);

       drawPulse(animationProgress);

       if (animationProgress < 1) {
         if (currentAnimation.timeouts.length > 0) {
           currentAnimation.requestId = requestAnimationFrame(animationStep);
         } else {
           ctx.clearRect(0, 0, width, height);
         }
       } else {
         if (tickNumber === totalTicks) {
           setTimeout(() => {
             if (!currentAnimation.requestId && currentAnimation.timeouts.length === 0) {
               ctx.clearRect(0, 0, width, height);
             }
           }, 100);
         }
       }
     }
    currentAnimation.requestId = requestAnimationFrame(animationStep);
  }

  function drawOscilloscope() {
    oscilloscopeAnimationId = requestAnimationFrame(drawOscilloscope);

    if (!analyser || !audioContext) return;

    const bufferLength = analyser.frequencyBinCount; 
    const dataArray = new Uint8Array(bufferLength);
    analyser.getByteTimeDomainData(dataArray); 
	
    const canvasWidth = oscilloscopeCanvas.width;
    const canvasHeight = oscilloscopeCanvas.height;

    oscilloscopeCtx.fillStyle = '#000000';
    oscilloscopeCtx.fillRect(0, 0, canvasWidth, canvasHeight);

    oscilloscopeCtx.lineWidth = 2;
    oscilloscopeCtx.strokeStyle = '#00FF00'; 
    oscilloscopeCtx.beginPath();

    const sliceWidth = canvasWidth * 1.0 / bufferLength;
    let x = 0;

    for (let i = 0; i < bufferLength; i++) {
      const v = dataArray[i] / 128.0; 
      const y = v * canvasHeight / 2; 

      if (i === 0) {
        oscilloscopeCtx.moveTo(x, y);
      } else {
        oscilloscopeCtx.lineTo(x, y);
      }

      x += sliceWidth;
    }

    oscilloscopeCtx.lineTo(canvasWidth, canvasHeight / 2);
    oscilloscopeCtx.stroke(); // Draw the path
  }


  function calculateAndDisplayDelays() {
    const bpm = parseFloat(bpmInput.value);
    const roundValues = roundToggle.checked;

    if (isNaN(bpm) || bpm <= 0) {
      resultsContainer.innerHTML = '<p style="color: #333; padding: 10px;">Enter a valid BPM to see delay times.</p>';
      return;
    }

    const quarterNoteDelay = 60000 / bpm;
    const groupedNotes = { standard: [], dotted: [], triplet: [] };

    noteDefinitions.forEach((note, index) => {
      let delayMs;
      if (note.type === "triplet") {
        delayMs = (quarterNoteDelay * note.baseNoteFactor) / note.divisor;
      } else {
        delayMs = quarterNoteDelay * note.factor;
      }

      const displayValue = roundValues ? Math.round(delayMs) : delayMs.toFixed(2);
      const canvasId = `canvas-${note.type}-${index}`;
      groupedNotes[note.type].push({
          name: note.name,
          value: displayValue,
          rawValue: delayMs,
          canvasId: canvasId,
          noteType: note.type
      });
    });

    const createSection = (title, notes) => {
      if (notes.length === 0) return '';
      let html = `<div class="section-title">${title}</div>`;
      notes.forEach(note => {
        html += `
          <div class="list-item"
               onclick="playDelayEffect(${note.rawValue}, '${note.canvasId}', '${note.noteType}')"
               title="Click to play ${note.name} delay (${note.value} ms)">
            <span class="note-name">${note.name}</span>
            <canvas id="${note.canvasId}" class="delay-canvas" width="30" height="30"></canvas>
            <span class="delay-value">${note.value} ms</span>
          </div>`;
      });
      return html;
    };

    resultsContainer.innerHTML =
      createSection("Standard Note Delays", groupedNotes.standard) +
      createSection("Dotted Note Delays", groupedNotes.dotted) +
      createSection("Triplet Note Delays", groupedNotes.triplet);
  }

  // --- Event Listeners ---
  bpmInput.addEventListener('input', calculateAndDisplayDelays);
  bpmInput.addEventListener('change', calculateAndDisplayDelays);
  roundToggle.addEventListener('change', calculateAndDisplayDelays);

  document.addEventListener('DOMContentLoaded', () => {
    currentYearSpan.textContent = new Date().getFullYear();
    if (!bpmInput.value) bpmInput.value = 120;
    calculateAndDisplayDelays();

    const oscContainer = document.getElementById('oscilloscope-container');
    oscilloscopeCanvas.width = oscContainer.clientWidth - 16; 
    oscilloscopeCanvas.height = 100; 
	spectrogramCanvas.width = oscContainer.clientWidth - 16;
	spectrogramCanvas.height = 80;


    const initializeOnFirstGesture = () => {
        initAudioContext();
        document.body.removeEventListener('click', initializeOnFirstGesture);
        document.body.removeEventListener('touchstart', initializeOnFirstGesture);
        document.body.removeEventListener('keydown', initializeOnFirstGesture);
    };
    document.body.addEventListener('click', initializeOnFirstGesture, { once: true });
    document.body.addEventListener('touchstart', initializeOnFirstGesture, { once: true });
    document.body.addEventListener('keydown', initializeOnFirstGesture, { once: true });
  });

  window.addEventListener('beforeunload', () => {
      clearInterval(bgInterval);
      stopCurrentEffects();
      if (oscilloscopeAnimationId) {
          cancelAnimationFrame(oscilloscopeAnimationId);
      }
      if(audioContext && audioContext.state !== 'closed') {
          audioContext.close();
      }
  });

  window.addEventListener('resize', () => {
  const oscContainer = document.getElementById('oscilloscope-container');
  if (oscContainer && oscilloscopeCanvas && spectrogramCanvas) {
    oscilloscopeCanvas.width = oscContainer.clientWidth - 16; 
    spectrogramCanvas.width = oscContainer.clientWidth - 16;
  }
});


  </script>
</body>
</html>
